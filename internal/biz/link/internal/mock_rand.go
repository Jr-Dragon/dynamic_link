// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package internal

import (
	"sync"
)

// Ensure, that RandGeneratorMock does implement RandGenerator.
// If this is not the case, regenerate this file with moq.
var _ RandGenerator = &RandGeneratorMock{}

// RandGeneratorMock is a mock implementation of RandGenerator.
//
//	func TestSomethingThatUsesRandGenerator(t *testing.T) {
//
//		// make and configure a mocked RandGenerator
//		mockedRandGenerator := &RandGeneratorMock{
//			StringFunc: func(n int, k uint32) string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedRandGenerator in code that requires RandGenerator
//		// and then make assertions.
//
//	}
type RandGeneratorMock struct {
	// StringFunc mocks the String method.
	StringFunc func(n int, k uint32) string

	// calls tracks calls to the methods.
	calls struct {
		// String holds details about calls to the String method.
		String []struct {
			// N is the n argument value.
			N int
			// K is the k argument value.
			K uint32
		}
	}
	lockString sync.RWMutex
}

// String calls StringFunc.
func (mock *RandGeneratorMock) String(n int, k uint32) string {
	if mock.StringFunc == nil {
		panic("RandGeneratorMock.StringFunc: method is nil but RandGenerator.String was just called")
	}
	callInfo := struct {
		N int
		K uint32
	}{
		N: n,
		K: k,
	}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc(n, k)
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedRandGenerator.StringCalls())
func (mock *RandGeneratorMock) StringCalls() []struct {
	N int
	K uint32
} {
	var calls []struct {
		N int
		K uint32
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}
